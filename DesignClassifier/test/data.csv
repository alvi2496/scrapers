number,comment
#12442,            
#12442,"See nodejs/CTC#12 for discussion/background. I would say that that thread is a better place for general discussion, and I prefer it if comments here would be kept to what is directly relevant for this PR. "
#12442,CI: https://ci.nodejs.org/job/node-test-commit/9143/ 
#12442,"Checklist   make -j4 test (UNIX), or vcbuild test (Windows) passes tests and/or benchmarks are included documentation is changed or added commit message follows commit guidelines "
#12442,Affected core subsystem(s) 
#12442,"util, timers "
#12442,Original commit descriptions 
#12442,util: add internal bindings for promise handling 
#12442,"Add methods for creating, resolving and rejecting promises using the V8 C++ API that does not require creation of extra resolve and reject functions to process.binding('util'). "
#12442,util: add util.promisify() 
#12442,Add util.promisify(function) for creating promisified functions. 
#12442,Fixes: nodejs/CTC#12 
#12442,timers: add promisify support 
#12442,Add support for util.promisify(setTimeout) and util.promisify(setImmediate) as a proof-of-concept implementation. clearTimeout() and clearImmediate() resolve the promise immediately instead of rejecting it; that might be the most opinionated choice about this. 
#12442,/cc @chrisdickinson @benjamingr @Fishrock123 @nodejs/ctc 
#12442,edit: CTC voting comment                  
#12442,"Also, @benjamingr has a good point about the naming, quote:  optimally I'd hope for most people to not even be aware of what a promise is in 5 years and just use async/await seamlessly :) "
#12442,"We can bikeshed this further here, but just to get an idea how people feel, could people üëç this comment for ‚Äúpromisify sounds good‚Äù and üëé this for ‚ÄúI‚Äôd prefer awaitable or something else‚Äù (both assuming that we agree on the approach in this PR in general)?                  "
#12442,Maybe we should split the timers bits into a second PR? They don't map well to promises since we don't have cancelables. Maybe we could plug the timers props onto the promise itself? Not sure.                  
#12442,"I.e. clearTimeout() should probably work on whatever setTimeoutPromise() returns (a promise but you get the idea), same for Immediates.                  "
#12442,"A big +1 on this. I think this could be a great first step for helping users deal with async/await in their code. There is a clear benefit over a userland implementation, and the need is prevalent.                  "
#12442,"Going to expand on my point a bit: I think this is reasonable to do for simple callback APIs but I think we should spend more* time to think about how to wrap more complex APIs such as timers, child processes, etc well.  * Might be good for an EP?                   Maybe we should split the timers bits into a second PR? "
#12442,"If that‚Äôs what people here prefer, sure. I just thought it made sense because they‚Äôre about the only API that‚Äôs a bit icky because they don‚Äôt conform to Node‚Äôs standard callback pattern, so whenever we introduce something like util.promisify() we‚Äôd probably also want to have support for promisified timers (in some way).  I.e. clearTimeout() should probably work on whatever setTimeoutPromise() returns (a promise but you get the idea), same for Immediates. "
#12442,"Makes sense, I‚Äôve updated the PR with isPromise(timer) checks anyway.                  "
#12442,"@Fishrock123  Going to expand on my point a bit: I think this is reasonable to do for simple callback APIs but I think we should spend more time to think about how to wrap more complex APIs such as timers, child processes, etc well. "
#12442,"I definitely agree - we need a proper promised core at some point - but #5020 and similar attempts have stagnated and quoting myself in the original issue:  The idea of util.awaitable vs a promise core is that it's hopefully a lot less objectionable, it poses a lot less controversy, it's a lot less opinionated and it means exposing a capability that users can build on and not an API.                  "
#12442,"I think @Fishrock123‚Äôs comment was about the timers stuff, not the general API here? I feel inclined to disagree that this needs an EP, though‚Ä¶                  "
#12442,Correct. I only mean for how to wrap any APIs that are more complex than single events or callbacks and which do not wrap as well.                  
#12442,"@TimothyGu Addressed most of your comments, PTAL                  "
#12442,"I just published https://www.npmjs.com/package/util.promisify (with code largely copy/pasted from this PR, with permission from @addaleax) for those interested.                    "
#12442,I (also) would like to see the timers impl in a followup PR.           
#12442,"This truthy test of orig is not needed since it is guaranteed to be a function at this point@williamkapke thanks for catching, donefunction isn't a legal identifier in JS, and for consistency we probably want to keep it legal.Lower case ""custom""I think the uppercase variant is okay here, it‚Äôs referring to a literal section title, and it matches what we do for the other two section references in this file. If you feel strongly about it I‚Äôll change it.An async function example would be cool as well.You probably want to clarify setImmediate() or its promisified equivalent.Ditto.""Using the util.promisify.custom symbol""?What about the prototype of orig?@TimothyGu yeah ‚Ä¶ that thought occurred to me, but I basically didn‚Äôt see how setting it would make sense here. If you prefer, I‚Äôll addYeah I don't see how it would matter that much in real world, but having that there does seem a bit more natural to me. Up to you if you want to set it or not.I don't think it would matter that much; it just occurred to me having the prototype being equivalent might be more natural. Up to you.@TimothyGu I‚Äôve included it for now, let‚Äôs see what people think.This seems like a bad idea for many reasons. I think it's fine if you can't cancel promisified timeout until we have some generic cancellation mechanism.This seems like a bad idea for many reasons.Would you care to provide some? Otherwise this is just not helpful.First of all, attaching properties to native objects seems like a bad idea from performance perspective. Secondly, this implements ad hoc cancellation mechanism, while there is no spec on standards track or even community consensus. This approach suffers from the fact that it's not propagated and there it doesn't play nice with async-await.I think it's fine to make promisified versions not cancellable. If you use them you are most likely not going to cancel anyway.First of all, attaching properties to native objects seems like a bad idea from performance perspective.That‚Äôs true, but it‚Äôs opt-in, right?This approach suffers from the fact that it's not propagatedWhat do you mean by propagated?But yeah, I would be okay with dropping clear* support for these, at least for the time being.What do you mean by propagated?Something like this:I have to agree with @vkurchatkin on this. Until there is a standard way of canceling promises, we likely shouldn't do this.@vkurchatkin @jasnell Okay, I‚Äôve dropped clearTimeout/clearImmediate support. It‚Äôs a niche feature anyway and it should be easy to readjust later if we want.Nit: first may not be necessary hereYou‚Äôre right. I wanted to phrase this error message in a way that makes it as unlikely as possible that changing it is semver-major, but if you prefer another wording, I‚Äôll gladly change it. üòÑI was thinking maybe we can just drop first. When I read the error message, my mind understood that as there are more than one argument. Not a big deal though.There are few cases where we pass more than one value like in fs.readSo ‚Ä¶ if you like, I can check for those APIs and add custom code for them in this PR? I think that makes sense but maybe not everybody is comfortable with yet more changes in here‚Ä¶We can use rest operator with data and with an if condition this can be fixed, right? Only thing is the resolved value will be an array for these special cases.@thefourtheye We have about 6 top-level functions doing that, I‚Äôve taken a stab at addressing them in a clean way in this PR (see the most recent 3 commits)‚Ä¶ please take a look :)If the original immediate was a promise not coming from setImmediate(), immediate should be undefined here, and this might crash. Not sure if we want that.This code doesn‚Äôt have any typechecks right now anyway, you can just pass in anything and hope it doesn‚Äôt go up in flames.I don't think it would matter that much; it just occurred to me having the prototype being equivalent might be more natural. Up to you.Is this function basically equivalent to passing a dummy function to the Promise constructor?I think so. It‚Äôs using V8s internal promise creation mechanism instead of the full Promise constructor ‚Ä¶ I would assume the latter is built upon the former, but I haven‚Äôt checked that. If you want, I can try to look it up.This is internally implemented by basically calling new Promise() with no closure argument. However, the great thing is that, since you're using the V8 API, you can still resolve and reject it, even though no closures are allocated (because they won't leak).I'd make sure this doesn't decrease the performance of getting fn's properties; if in doubt, an if (Object.getPrototypeOf(fn) !== Object.getPrototypeOf(orig)) might be good.V8 implements setPrototypeOf as a no-op if they are already equal, I‚Äôve checked that in the past to be sure. üòÑPromises are idempotent right? Should we really do this?It's to check that the promise is pending at that point. It might not be necessary but not because of idempotence.Hm, maybe it is necessary to always check for that‚Ä¶ some really weird userland functions could schedule the callback to run and then throw after that. (And using this code would actually change the Promise state.)I‚Äôve updated this to return as a no-op when the promise is not pending.Nice, this looks better than the throwing to me. Thanks :)This catch may accidentally catch errors thrown from promiseReject if orig.call happened to be synchronous. E.g. the value was cached in memory and didn't need a remote lookup. promiseReject on line 264 will be a no-op in that case.Ideally if the execution hit line 253 and then 264, it should re-throw the error instead of no-oping. At least it could log a warning.The existing way is definitely better; a function that returns a promise should never throw, only return a rejected promise.@syrnick can you please open an issue about it?(also, since a promise can only represent one value; new Promise((resolve, reject) => { reject(1); reject(2); }) is supposed to have the second rejection be a noop, and does not throw the 2, so it'd be important for util.promisify to maintain parity)What's the motivation for keeping this private? It's obviously useful in a number of places.https://github.com/nodejs/node/pull/12442/files#diff-a43208147d795be6dd3517c53226e37dR280 ?but that's still on internal/util, not accessible to user code. The other one(kCustomPromisifiedSymbol) is available as util.promisify.custom.@syrnick See #14007."
